# Accelerating_My_Dream_With_Techdose

## Day1 pg 1-9
	* Time Complexity Analysis
	* MasterTheorem


## Day2 pg 9-16
	* Bit Manipulation - NOT,AND,OR,XOR,LEFT and RIGHT SHIFT
	* 1.IF n is power of 2 - logn , O(1)
	* 2.Counting Set Bits - logn , o(set_bits)Brian Algo, theta(1) table lookup 
	* 3.Check if kth bit is set or not - o(1)
	* 4.DP and BitMasking - Generate all possible subsets - n*2pown
	* 5.Compute XOR from 1toN - O(1)
	* 6.Bitwise and of number range - O(set_bits)
	* LC-136,137,169,201,338,461,11734
## Day3 pg 17-28
	* Mahtematics
	1. Base conversion
	2. N is prime or not - (sqrt(n))
	3. All factors in a number - (sqrt(n))
	4. Find all prime from 1 to N - (n*sqrt(n)),  Sieve of Eratosthenes - nloglogn
	5. Prime factors of N - - (sqrt(n))
	6. Coeff of NCr - DP app - (n^2)
	HW1. If n is fixed, how to do in 1d table
	7. Distributive Property to handle representation overflow
	8. Euclidean algo -  log(min(A,B))
	9. Binary Exponentiation - itr - logn(b) for a^b
	10. Catylyan Numbet
		a.The no. of valid () expression that consist N right () and N left () is Cn
		b. A rooted BT with one root node where each node has either 0 or 2 branches
		   An internal node has 2 branches and leaf node has 0. Count how many rooted BTs are there with N interanal node
		c. Count no of ways to divide circle using N non-intersecting chords
		d. Cn is the no of diff ways (N+1) factor can completely ()sized. U cannot put single value in()
		e. Count structurally unique BSTs with N keys.
		f. In a NxN matrix number of ways to to reach from bottom left -> top right diagonal using paths on either side of diagonal
		g. All possible BT with given inorder traversal
	HW2. Read article/blog on c,e,f.
	
